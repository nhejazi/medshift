utils::globalVariables(c("..eif_component_names", "..w_names"))

#' Cross-validated Evaluation of Efficient Influence Function Components
#'
#' @param fold Object specifying cross-validation folds as generated by a call
#'  to \code{origami::make_folds}.
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param delta A \code{numeric} value indicating the magnitude of shift in the
#'  treatment that defines the counterfactual quantity of interest. In the case
#'  of binary treatments, this defines the incremental propensity score shift,
#'  which acts as a multiplier of the odds with which an observational unit
#'  receives treatment (EH Kennedy, 2018; <doi:10.1080/01621459.2017.1422737>).
#'  When the treatment is quantitative, the defines the degree of shift for a
#'  modified treatment policy but non-binary treatments are not  yet supported.
#' @param g_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model.
#' @param e_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a reparametrized model
#'  for the mediator(s) that is equivalent to a propensity score conditioning
#'  on the mediators.
#' @param m_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit an outcome regression.
#' @param phi_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a nuisance regression of
#'  a "derived" pseudo-outcome (contrast of outcome regressions under different
#'  treatment conditions), conditional on baseline covariates. This is of the
#'  following form phi(W) = E[m(A = 1, Z, W) - m(A = 0, Z, W) | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table data.table
#' @importFrom origami training validation fold_index
#'
#' @keywords internal
stoch_cv_eif <- function(fold,
                         data,
                         delta,
                         g_learners,
                         e_learners,
                         m_learners,
                         phi_learners,
                         w_names,
                         z_names) {
  # make training and validation data
  train_data <- origami::training(data)
  valid_data <- origami::validation(data)

  # compute nuisance parameters eta = (g, m, e, phi)
  ## 1) fit regression for incremental propensity score intervention
  g_out <- lapply(delta, function(delta) {
    # NOTE: even this is _repeated_ computation since delta is a multiplier
    #       ...worth fixing later if a bottleneck.
    g_est_delta <- fit_g_mech(
      data = train_data, valid_data = valid_data,
      delta = delta,
      learners = g_learners, w_names = w_names
    )
    return(g_est_delta)
  })

  ## 2) fit clever regression for treatment, conditional on mediators
  e_out <- fit_e_mech(
    data = train_data, valid_data = valid_data,
    learners = e_learners,
    z_names = z_names, w_names = w_names
  )

  ## 3) fit regression for incremental propensity score intervention
  m_out <- fit_m_mech(
    data = train_data, valid_data = valid_data,
    learners = m_learners,
    z_names = z_names, w_names = w_names
  )

  ## 4) difference-reduced dimension regression with pseudo-outcome
  phi_est <- fit_phi_mech(
    train_data = train_data, valid_data = valid_data,
    learners = phi_learners,
    m_out = m_out, w_names = w_names
  )

  # loop over each delta-shift in grid to assemble EIF components
  eif_over_delta <- lapply(seq_along(delta), function(delta_iter) {
    # compute component Dzw from nuisance parameters
    Dzw_groupwise <- compute_Dzw(
      g_out = g_out[[delta_iter]], m_out = m_out
    )
    D_ZW <- Dzw_groupwise$dzw_cntrl + Dzw_groupwise$dzw_treat

    # compute component Da from nuisance parameters
    g_pred_A1 <- g_out[[delta_iter]]$g_est$g_pred_natural_A1
    g_pred_A0 <- g_out[[delta_iter]]$g_est$g_pred_natural_A0
    Da_numerator <- delta[delta_iter] * phi_est * (valid_data$A - g_pred_A1)
    Da_denominator <- (delta[delta_iter] * g_pred_A1 + g_pred_A0)^2
    D_A <- Da_numerator / Da_denominator

    # compute component Dy from nuisance parameters
    m_pred_obs <- valid_data$A * m_out$m_est$m_pred_Ais1 + (1 - valid_data$A) *
      m_out$m_est$m_pred_Ais0

    # stabilize weights (dividing by sample average) and compute IPW estimate
    g_shifted <- valid_data$A * g_out[[delta_iter]]$g_est$g_pred_shifted_A1 +
      (1 - valid_data$A) * g_out[[delta_iter]]$g_est$g_pred_shifted_A0

    e_pred <- valid_data$A * e_out$e_est$e_pred_natural_A1 +
      (1 - valid_data$A) * e_out$e_est$e_pred_natural_A0
    mean_weights <- mean(g_shifted / e_pred)

    # compute component of EIF associated to Y
    D_Y <- ((g_shifted / e_pred) / mean_weights) * (valid_data$Y - m_pred_obs)

    # output table of EIF results for given shift
    eif_out <- data.table::data.table(
      Dy = D_Y, Da = D_A, Dzw = D_ZW,
      fold = origami::fold_index()
    )
    return(eif_out)
  })

  # output
  return(eif_over_delta)
}

###############################################################################

#' Construct joint mediator-baseline score of efficient influence function
#'
#' @param g_out Object containing results from fitting the propensity score
#'  regression, as produced by a call to \code{\link{fit_g_mech}}.
#' @param m_out Object containing results from fitting the outcome
#'  regression, as produced by a call to \code{\link{fit_m_mech}}.
#'
#' @keywords internal
compute_Dzw <- function(g_out, m_out) {
  # get g components from output for that nuisance parameter
  g_shifted_A1 <- g_out$g_est$g_pred_shifted_A1
  g_shifted_A0 <- g_out$g_est$g_pred_shifted_A0

  # get m components from output for that nuisance parameter
  m_pred_Ais1 <- m_out$m_est$m_pred_Ais1
  m_pred_Ais0 <- m_out$m_est$m_pred_Ais0

  # compute component Dzw from nuisance parameters
  Dzw_A1 <- g_shifted_A1 * m_pred_Ais1
  Dzw_A0 <- g_shifted_A0 * m_pred_Ais0

  # output as simple list
  return(list(
    dzw_cntrl = Dzw_A0,
    dzw_treat = Dzw_A1
  ))
}

###############################################################################

interv_cv_eif <- function(fold,
                          data,
                          delta,
                          g_learners,
                          e_learners,
                          b_learners,
                          d_learners,
                          m_learners,
                          w_names,
                          z_names) {
  # make training and validation data
  train_data <- origami::training(data)
  valid_data <- origami::validation(data)

  ## 1) fit propensity score with incremental propensity score intervention
  g_out <- fit_g_mech(
    data = train_data, valid_data = valid_data, delta = delta,
    learners = g_learners, w_names = w_names
  )

  ## 2) fit reparameterized propensity score, conditional on mediators
  e_out <- fit_e_mech(
    data = train_data, valid_data = valid_data, learners = e_learners,
    z_names = z_names, w_names = w_names
  )

  ## 3) fit intermediate confounding mechanism without mediators
  b_out <- fit_b_mech(
    data = train_data, valid_data = valid_data, learners = b_learners,
    w_names = w_names
  )

  ## 4) fit reparameterized intermediate confounding mechanism,
  #     conditional on mediators
  d_out <- fit_d_mech(
    data = train_data, valid_data = valid_data, learners = d_learners,
    z_names = z_names, w_names = w_names
  )

  ## 5) fit outcome regression
  m_out <- fit_m_mech(
    data = train_data, valid_data = valid_data, learners = m_learners,
    z_names = z_names, w_names = w_names
  )

  # TODO:
}
