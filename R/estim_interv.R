utils::globalVariables(
  c("..w_names", "..z_names", ".N", "m_pred_Lnat_Anat", "b_pred_L1_Anat",
    "m_pred_Lis1_Ais1", "m_pred_Lis1_Ais0", "m_pred_Lis0_Ais1",
    "m_pred_Lis0_Ais0", "g_pred_natural_A1", "g_pred_shifted_A1",
    "g_pred_Anat", "g_pred_shifted_Anat", "b_pred_Lnat", "u_pred_Anat",
    "u_pred_Ais1", "u_pred_Ais0", "u_pred_Ais1_intZ", "u_pred_Ais0_intZ",
    "u_pred_Anat_intZ")
)

#' Compute Cross-Fitted One-Step Estimator
#'
#' @param data ...
#' @param delta ...
#' @param g_learners ...
#' @param e_learners ...
#' @param b_learners ...
#' @param d_learners ...
#' @param m_learners ...
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param cv_folds ...
#'
#' @importFrom data.table rbindlist
#' @importFrom origami make_folds folds_vfold cross_validate
#' @importFrom stats var
#' @importFrom tibble as_tibble
interv_est_onestep <- function(data,
                               delta,
                               g_learners,
                               e_learners,
                               b_learners,
                               d_learners,
                               m_learners,
                               w_names,
                               z_names,
                               cv_folds = 5L) {

  # create folds for use with origami::cross_validate
  folds <- origami::make_folds(data,
    fold_fun = origami::folds_vfold,
    V = cv_folds,
    cluster_ids = data[["ids"]]
  )
  validx <- lapply(folds, `[[`, "validation_set")
  reorder_validx <- order(do.call(c, validx))

  # perform the cv_eif procedure on a per-fold basis
  cv_eif_results <- origami::cross_validate(
    cv_fun = interv_cv_eif,
    folds = folds,
    data = data,
    delta = delta,
    g_learners = g_learners,
    e_learners = e_learners,
    b_learners = b_learners,
    d_learners = d_learners,
    m_learners = m_learners,
    w_names = w_names,
    z_names = z_names,
    use_future = FALSE,
    .combine = FALSE
  )
  cv_eif_results <- data.table::rbindlist(cv_eif_results[[1]])
  cv_eif_results <- cv_eif_results[reorder_validx, ]

  # compute auxiliary covariates
  h_aux_direct <- with(cv_eif_results,
    b_pred_Lnat / d_pred_Lnat *
    (1 - g_pred_shifted_Anat / e_pred_Anat)
  )
  h_aux_indirect <- with(cv_eif_results,
    b_pred_Lnat / d_pred_Lnat * g_pred_shifted_Anat *
    (1 / e_pred_Anat - 1 / g_pred_Anat)
  )

  k_aux_direct <- with(cv_eif_results,
    (v_pred_Lis1 - v_pred_Lis0) - (g_pred_shifted_Anat /
    g_pred_Anat) * (s_pred_Lis1 - s_pred_Lis0)
  )
  k_aux_indirect <- with(cv_eif_results,
    (g_pred_shifted_Anat / g_pred_Anat) *
    (s_pred_Lis1 - s_pred_Lis0 - v_pred_Lis1 + v_pred_Lis0)
  )

  m_aux_direct <- with(cv_eif_results,
    ((-g_pred_shifted_A1 * g_pred_shifted_A0) /
    (g_pred_natural_A1 * g_pred_natural_A0)) * u_diff_pred
  )
  m_aux_indirect <- with(cv_eif_results,
    ((g_pred_shifted_A1 * g_pred_shifted_A0) /
    (g_pred_natural_A1 * g_pred_natural_A0)) *
    (u_diff_pred - u_diff_pred_intZ)
  )
  j_aux <- with(cv_eif_results,
    -g_pred_shifted_Anat / g_pred_Anat
  )

  # compute one-step estimate and uncentered EIF for direct effect
  est_direct <- with(cv_eif_results,
    u_pred_Ais1_intZ * g_pred_natural_A1 +
    u_pred_Ais0_intZ * g_pred_natural_A0 -
    (u_pred_Ais1 * g_pred_shifted_A1 +
     u_pred_Ais0 * g_pred_shifted_A0)
  )
  eif_direct <- est_direct +
    h_aux_direct * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
    k_aux_direct * (data$L - cv_eif_results$b_pred_L1_Anat) +
    m_aux_direct * (data$A - cv_eif_results$g_pred_natural_A1) +
    (cv_eif_results$u_pred_Anat - cv_eif_results$u_pred_Anat_intZ)

  # compute one-step estimate uncentered EIF for indirect effect
  est_indirect <- with(cv_eif_results,
    (u_pred_Ais1 - u_pred_Ais1_intZ) * g_pred_shifted_A1 +
    (u_pred_Ais0 - u_pred_Ais0_intZ) * g_pred_shifted_A0
  )
  eif_indirect <- est_indirect +
    h_aux_indirect * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
    k_aux_indirect * (data$L - cv_eif_results$b_pred_L1_Anat) +
    m_aux_indirect * (data$A - cv_eif_results$g_pred_natural_A1) +
    j_aux * (cv_eif_results$u_pred_Anat - cv_eif_results$u_pred_Anat_intZ)

  # compute one-step estimators and estimated standard errors
  os_est_direct <- mean(eif_direct)
  stderr_direct <- sqrt(stats::var(eif_direct) / data[, .N])
  os_est_indirect <- mean(eif_indirect)
  stderr_indirect <- sqrt(stats::var(eif_indirect) / data[, .N])

  # create output and return
  os_est_out <- tibble::as_tibble(list(
    param = c("direct", "indirect"),
    est = c(os_est_direct, os_est_indirect),
    stderr = c(stderr_direct, stderr_indirect)
  ))
  attr(os_est_out, "param") <- "stochastic_interventional"
  return(os_est_out)
}

###############################################################################

#' Compute Cross-Validated Targeted Minimum Loss-based Estimator (CV-TMLE)
#'
#' @param data ...
#' @param delta ...
#' @param g_learners ...
#' @param e_learners ...
#' @param b_learners ...
#' @param d_learners ...
#' @param m_learners ...
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param cv_folds ...
#' @param max_iter ...
#' @param tol_tilt ...
#'
#' @importFrom data.table ":=" data.table rbindlist
#' @importFrom origami make_folds folds_vfold cross_validate
#' @importFrom stats coef glm offset plogis qlogis predict var
#' @importFrom tibble as_tibble
interv_est_tmle <- function(data,
                            delta,
                            g_learners,
                            e_learners,
                            b_learners,
                            d_learners,
                            m_learners,
                            w_names,
                            z_names,
                            cv_folds = 5L,
                            max_iter = 10L,
                            tol_tilt = 10L) {

  # create folds for use with origami::cross_validate
  folds <- origami::make_folds(data,
    fold_fun = origami::folds_vfold,
    V = cv_folds,
    cluster_ids = data[["ids"]]
  )
  validx <- lapply(folds, `[[`, "validation_set")
  reorder_validx <- order(do.call(c, validx))

  # perform the cv_eif procedure on a per-fold basis
  cv_eif_results <- origami::cross_validate(
    cv_fun = interv_cv_eif,
    folds = folds,
    data = data,
    delta = delta,
    g_learners = g_learners,
    e_learners = e_learners,
    b_learners = b_learners,
    d_learners = d_learners,
    m_learners = m_learners,
    w_names = w_names,
    z_names = z_names,
    use_future = FALSE,
    .combine = FALSE
  )
  cv_eif_results <- data.table::rbindlist(cv_eif_results[[1]])
  cv_eif_results <- cv_eif_results[reorder_validx, ]

  # compute auxiliary covariates
  h_aux_direct <- with(cv_eif_results,
    b_pred_Lnat / d_pred_Lnat *
    (1 - g_pred_shifted_Anat / e_pred_Anat)
  )
  h_aux_indirect <- with(cv_eif_results,
    b_pred_Lnat / d_pred_Lnat * g_pred_shifted_Anat *
    (1 / e_pred_Anat - 1 / g_pred_Anat)
  )

  k_aux_direct <- with(cv_eif_results,
    (v_pred_Lis1 - v_pred_Lis0) - (g_pred_shifted_Anat /
    g_pred_Anat) * (s_pred_Lis1 - s_pred_Lis0)
  )
  k_aux_indirect <- with(cv_eif_results,
    (g_pred_shifted_Anat / g_pred_Anat) *
    (s_pred_Lis1 - s_pred_Lis0 - v_pred_Lis1 + v_pred_Lis0)
  )

  m_aux_direct <- with(cv_eif_results,
    ((-g_pred_shifted_A1 * g_pred_shifted_A0) /
    (g_pred_natural_A1 * g_pred_natural_A0)) * u_diff_pred
  )
  m_aux_indirect <- with(cv_eif_results,
    ((g_pred_shifted_A1 * g_pred_shifted_A0) /
    (g_pred_natural_A1 * g_pred_natural_A0)) *
    (u_diff_pred - u_diff_pred_intZ)
  )
  j_aux <- with(cv_eif_results,
    -g_pred_shifted_Anat / g_pred_Anat
  )

  # compute EIFs for direct and indirect effects for stopping criteria
  eif_direct <-
    h_aux_direct * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
    k_aux_direct * (data$L - cv_eif_results$b_pred_L1_Anat) +
    m_aux_direct * (data$A - cv_eif_results$g_pred_natural_A1) +
    (cv_eif_results$u_pred_Anat - cv_eif_results$u_pred_Anat_intZ)

  # compute EIF for indirect effect with targeted nuisance estimates
  eif_indirect <-
    h_aux_indirect * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
    k_aux_indirect * (data$L - cv_eif_results$b_pred_L1_Anat) +
    m_aux_indirect * (data$A - cv_eif_results$g_pred_natural_A1) +
    j_aux * (cv_eif_results$u_pred_Anat - cv_eif_results$u_pred_Anat_intZ)

  # compute stopping criteria using EIF standard error at initial estimates
  var_eifs <- c(stats::var(eif_direct), stats::var(eif_indirect)) / data[, .N]
  tmle_crit <- max(sqrt(var_eifs) / max(10, log(data[, .N])))
  stop_crit <- FALSE
  tmle_iter <- 1L

  # iteratively compute TMLE
  while (!stop_crit) {
    # rescale predictions to the unit interval for logistic tilting
    m_pred_rescaled <- scale_to_unit(cv_eif_results$m_pred_Lnat_Anat)
    y_rescaled <- scale_to_unit(data$Y)

    # fit targeting submodel for outcome
    suppressWarnings(
      m_tilt <- stats::glm(
        formula = "y_star ~ -1 + h_de + h_ie + offset(m_pred)",
        family = "binomial",
        start = c(0, 0),
        data = data.table::data.table(
          y_star = y_rescaled,
          m_pred =  stats::qlogis(bound_precision(m_pred_rescaled)),
          h_de = h_aux_direct,
          h_ie = h_aux_indirect
        )
      )
    )
    m_tilt <- check_fluc(m_tilt, tol_tilt)

    # extract targeted predictions and rescale to original outcome bounds
    m_tilt_pred <- unname(stats::predict(m_tilt, type = "response"))
    attr(m_tilt_pred, "max") <- attr(y_rescaled, "max")
    attr(m_tilt_pred, "min") <- attr(y_rescaled, "min")
    m_tilt_pred <- scale_from_unit(m_tilt_pred)
    cv_eif_results[, m_pred_Lnat_Anat := m_tilt_pred]

    # fit targeting submodel for intermediate confounder
    suppressWarnings(
      b_tilt <- stats::glm(
        formula = "l_star ~ -1 + k_de + k_ie + offset(b_pred)",
        family = "binomial",
        start = c(0, 0),
        data = data.table::data.table(
          l_star = scale_to_unit(data$L),
          b_pred = stats::qlogis(
            bound_precision(cv_eif_results$b_pred_L1_Anat)
          ),
          k_de = k_aux_direct,
          k_ie = k_aux_indirect
        )
      )
    )
    b_tilt <- check_fluc(b_tilt, tol_tilt)

    # extract targeted predictions for intermediate confounding mechanism
    b_tilt_pred <- unname(stats::predict(b_tilt, type = "response"))
    cv_eif_results[, b_pred_L1_Anat := b_tilt_pred]

    # fit targeted submodel for treatment mechanism
    suppressWarnings(
      g_tilt <- stats::glm(
        formula = "a_star ~ -1 + m_de + m_ie + offset(g_pred)",
        family = "binomial",
        start = c(0, 0),
        data = data.table::data.table(
          a_star = scale_to_unit(data$A),
          g_pred = stats::qlogis(
            bound_precision(cv_eif_results$g_pred_natural_A1)
          ),
          m_de = m_aux_direct,
          m_ie = m_aux_indirect
        )
      )
    )
    g_tilt <- check_fluc(g_tilt, tol_tilt)

    # extracted targeted predictions for treatment mechanism
    g_tilt_pred <- unname(stats::predict(g_tilt, type = "response"))
    g_tilt_pred_ipsi <- ipsi_delta(g_tilt_pred, delta)
    cv_eif_results[, g_pred_natural_A1 := g_tilt_pred]
    cv_eif_results[, g_pred_shifted_A1 := g_tilt_pred_ipsi]

    # update auxiliary covariates for targeting of direct effect nuisances
    h_aux_direct_L1_A1 <- with(cv_eif_results,
      b_pred_L1_Ais1 / d_pred_L1_Ais1 *
        (1 - g_pred_shifted_A1 / e_pred_natural_A1)
    )
    h_aux_direct_L1_A0 <- with(cv_eif_results,
      b_pred_L1_Ais0 / d_pred_L1_Ais0 *
        (1 - (1 - g_pred_shifted_A1) / e_pred_natural_A0)
    )
    h_aux_direct_L0_A1 <- with(cv_eif_results,
      (1 - b_pred_L1_Ais1) / (1 - d_pred_L1_Ais1) *
        (1 - g_pred_shifted_A1 / e_pred_natural_A1)
    )
    h_aux_direct_L0_A0 <- with(cv_eif_results,
      (1 - b_pred_L1_Ais0) / (1 - d_pred_L1_Ais0) *
        (1 - (1 - g_pred_shifted_A1) / e_pred_natural_A0)
    )

    # update auxiliary covariates for targeting of indirect effect nuisances
    h_aux_indirect_L1_A1 <- with(cv_eif_results,
      b_pred_L1_Ais1 / d_pred_L1_Ais1 * g_pred_shifted_A1 *
        (1 / e_pred_natural_A1 - 1 / g_pred_natural_A1)
    )
    h_aux_indirect_L1_A0 <- with(cv_eif_results,
      b_pred_L1_Ais0 / d_pred_L1_Ais0 * (1 - g_pred_shifted_A1) *
        (1 / e_pred_natural_A0 - 1 / (1 - g_pred_natural_A1))
    )
    h_aux_indirect_L0_A1 <- with(cv_eif_results,
      (1 - b_pred_L1_Ais1) / (1 - d_pred_L1_Ais1) * g_pred_shifted_A1 *
        (1 / e_pred_natural_A1 - 1 / g_pred_natural_A1)
    )
    h_aux_indirect_L0_A0 <- with(cv_eif_results,
      (1 - b_pred_L1_Ais0) / (1 - d_pred_L1_Ais0) * (1 - g_pred_shifted_A1) *
        (1 / e_pred_natural_A0 - 1 / (1 - g_pred_natural_A1))
    )

    # rescaled outcome estimates across contrasts of L and A
    m_pred_Lis1_Ais1_rescaled <- scale_to_unit(
      cv_eif_results$m_pred_Lis1_Ais1
    )
    m_pred_Lis1_Ais0_rescaled <- scale_to_unit(
      cv_eif_results$m_pred_Lis1_Ais0
    )
    m_pred_Lis0_Ais1_rescaled <- scale_to_unit(
      cv_eif_results$m_pred_Lis0_Ais1
    )
    m_pred_Lis0_Ais0_rescaled <- scale_to_unit(
      cv_eif_results$m_pred_Lis0_Ais0
    )

    # update outcome estimates across contrasts of L and A
    m_pred_L1_A1 <- stats::plogis(
      stats::qlogis(bound_precision(m_pred_Lis1_Ais1_rescaled)) +
      stats::coef(m_tilt)[1] * h_aux_direct_L1_A1 +
      stats::coef(m_tilt)[2] * h_aux_indirect_L1_A1
    )
    attr(m_pred_L1_A1, "max") <- attr(m_pred_Lis1_Ais1_rescaled, "max")
    attr(m_pred_L1_A1, "min") <- attr(m_pred_Lis1_Ais1_rescaled, "min")
    cv_eif_results[, m_pred_Lis1_Ais1 := scale_from_unit(m_pred_L1_A1)]

    m_pred_L1_A0 <- stats::plogis(
      stats::qlogis(bound_precision(m_pred_Lis1_Ais0_rescaled)) +
      stats::coef(m_tilt)[1] * h_aux_direct_L1_A0 +
      stats::coef(m_tilt)[2] * h_aux_indirect_L1_A0
    )
    attr(m_pred_L1_A0, "max") <- attr(m_pred_Lis1_Ais0_rescaled, "max")
    attr(m_pred_L1_A0, "min") <- attr(m_pred_Lis1_Ais0_rescaled, "min")
    cv_eif_results[, m_pred_Lis1_Ais0 := scale_from_unit(m_pred_L1_A0)]

    m_pred_L0_A1 <- stats::plogis(
      stats::qlogis(bound_precision(m_pred_Lis0_Ais1_rescaled)) +
      stats::coef(m_tilt)[1] * h_aux_direct_L0_A1 +
      stats::coef(m_tilt)[2] * h_aux_indirect_L0_A1
    )
    attr(m_pred_L0_A1, "max") <- attr(m_pred_Lis0_Ais1_rescaled, "max")
    attr(m_pred_L0_A1, "min") <- attr(m_pred_Lis0_Ais1_rescaled, "min")
    cv_eif_results[, m_pred_Lis0_Ais1 := scale_from_unit(m_pred_L0_A1)]

    m_pred_L0_A0 <- stats::plogis(
      stats::qlogis(bound_precision(m_pred_Lis0_Ais0_rescaled)) +
      stats::coef(m_tilt)[1] * h_aux_direct_L0_A0 +
      stats::coef(m_tilt)[2] * h_aux_indirect_L0_A0
    )
    attr(m_pred_L0_A0, "max") <- attr(m_pred_Lis0_Ais0_rescaled, "max")
    attr(m_pred_L0_A0, "min") <- attr(m_pred_Lis0_Ais0_rescaled, "min")
    cv_eif_results[, m_pred_Lis0_Ais0 := scale_from_unit(m_pred_L0_A0)]

    # update nuisance estimates for next iteration of targeting
    g_pred_Anat_update <- data$A * cv_eif_results$g_pred_natural_A1 +
      (1 - data$A) * (1 - cv_eif_results$g_pred_natural_A1)
    g_pred_shifted_Anat_update <- data$A * cv_eif_results$g_pred_shifted_A1 +
      (1 - data$A) * (1 - cv_eif_results$g_pred_shifted_A1)
    b_pred_Lnat_update <- data$L * cv_eif_results$b_pred_L1_Anat +
      (1 - data$L) * (1 - cv_eif_results$b_pred_L1_Anat)

    # overwrite previous estimates with updated estimates
    cv_eif_results[, g_pred_Anat := g_pred_Anat_update]
    cv_eif_results[, g_pred_shifted_Anat := g_pred_shifted_Anat_update]
    cv_eif_results[, b_pred_Lnat := b_pred_Lnat_update]

    # update auxiliary covariates for next iteration of targeting
    h_aux_direct <- with(cv_eif_results,
      b_pred_Lnat / d_pred_Lnat *
      (1 - g_pred_shifted_Anat / e_pred_Anat)
    )
    h_aux_indirect <- with(cv_eif_results,
      b_pred_Lnat / d_pred_Lnat * g_pred_shifted_Anat *
      (1 / e_pred_Anat - 1 / g_pred_Anat)
    )

    k_aux_direct <- with(cv_eif_results,
      (v_pred_Lis1 - v_pred_Lis0) - (g_pred_shifted_Anat /
      g_pred_Anat) * (s_pred_Lis1 - s_pred_Lis0)
    )
    k_aux_indirect <- with(cv_eif_results,
      (g_pred_shifted_Anat / g_pred_Anat) *
      (s_pred_Lis1 - s_pred_Lis0 - v_pred_Lis1 + v_pred_Lis0)
    )

    m_aux_direct <- with(cv_eif_results,
      ((-g_pred_shifted_A1 * (1 - g_pred_shifted_A1)) /
      (g_pred_natural_A1 * (1 - g_pred_natural_A1))) * u_diff_pred
    )
    m_aux_indirect <- with(cv_eif_results,
      ((g_pred_shifted_A1 * (1 - g_pred_shifted_A1)) /
      (g_pred_natural_A1 * (1 - g_pred_natural_A1))) *
      (u_diff_pred - u_diff_pred_intZ)
    )

    # compute EIF for direct effect with targeted nuisance estimates
    eif_direct_cent <-
      h_aux_direct * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
      k_aux_direct * (data$L - cv_eif_results$b_pred_L1_Anat) +
      m_aux_direct * (data$A - cv_eif_results$g_pred_natural_A1)

    # compute EIF for indirect effect with targeted nuisance estimates
    eif_indirect_cent <-
      h_aux_indirect * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
      k_aux_indirect * (data$L - cv_eif_results$b_pred_L1_Anat) +
      m_aux_indirect * (data$A - cv_eif_results$g_pred_natural_A1)

    # check stopping criteria and increment the iterator
    eif_means <- max(abs(c(mean(eif_direct_cent), mean(eif_indirect_cent))))
    eif_crit <- eif_means < tmle_crit
    tmle_iter <- tmle_iter + 1L
    stop_crit <- eif_crit | (tmle_iter > max_iter)
  }

  # update auxiliary covariates for targeting derived nuisance estimates
  j_aux <- with(cv_eif_results,
    - g_pred_shifted_Anat / g_pred_Anat
  )
  j_aux_A1 <- with(cv_eif_results,
    - g_pred_shifted_A1 / g_pred_natural_A1
  )
  j_aux_A0 <- with(cv_eif_results,
    - (1 - g_pred_shifted_A1) / (1 - g_pred_natural_A1)
  )

  # update nuisance parameters to compute derived nuisances
  m_pred_L1_Anat <- data$A * cv_eif_results$m_pred_Lis1_Ais1 +
    (1 - data$A) * cv_eif_results$m_pred_Lis1_Ais0
  m_pred_L0_Anat <- data$A * cv_eif_results$m_pred_Lis0_Ais1 +
    (1 - data$A) * cv_eif_results$m_pred_Lis0_Ais1

  # setup derived nuisance estimates for targeted updating
  u_pred_Anat_updated <- m_pred_L1_Anat * cv_eif_results$b_pred_L1_Anat +
    m_pred_L0_Anat * (1 - cv_eif_results$b_pred_L1_Anat)
  cv_eif_results[, u_pred_Anat := u_pred_Anat_updated]

  u_pred_Ais1_updated <- with(cv_eif_results,
    m_pred_Lis1_Ais1 * b_pred_L1_Ais1 +
      m_pred_Lis0_Ais1 * (1 - b_pred_L1_Ais1)
  )
  cv_eif_results[, u_pred_Ais1 := u_pred_Ais1_updated]

  u_pred_Ais0_final <- with(cv_eif_results,
    m_pred_Lis1_Ais0 * b_pred_L1_Ais0 +
      m_pred_Lis0_Ais0 * (1 - b_pred_L1_Ais0)
  )
  cv_eif_results[, u_pred_Ais0 := u_pred_Ais0_final]

  # rescale derived nuisances for logistic submodel targeting
  u_pred_Anat_intZ_rescaled <- scale_to_unit(
    cv_eif_results$u_pred_Anat_intZ
  )
  u_pred_Anat_rescaled <- scale_to_unit(
    cv_eif_results$u_pred_Anat
  )

  # fit targeting submodel for derived nuisance estimates
  suppressWarnings(
    u_tilt <- stats::glm(
      formula = "u_pred_Anat ~ offset(u_pred_Anat_intZ) + j_aux",
      family = "binomial",
      start = c(0, 0),
      data = data.table::data.table(
        u_pred_Anat = u_pred_Anat_rescaled,
        u_pred_Anat_intZ = stats::qlogis(
          bound_precision(u_pred_Anat_intZ_rescaled)
        ),
        j_aux = j_aux
      )
    )
  )
  u_tilt <- check_fluc(u_tilt, tol_tilt)

  # update nuisance estimates based on targeting
  u_pred_Ais1_intZ_rescaled <- scale_to_unit(
    cv_eif_results$u_pred_Ais1_intZ
  )
  u_pred_Ais1_intZ_updated <- stats::plogis(
    stats::coef(u_tilt)[1] +
      stats::qlogis(bound_precision(u_pred_Ais1_intZ_rescaled)) +
    stats::coef(u_tilt)[2] * j_aux_A1
  )
  u_pred_Ais1_intZ_updated <- scale_from_unit(u_pred_Ais1_intZ_updated)
  cv_eif_results[, u_pred_Ais1_intZ := u_pred_Ais1_intZ_updated]

  u_pred_Ais0_intZ_rescaled <- scale_to_unit(
    cv_eif_results$u_pred_Ais0_intZ
  )
  u_pred_Ais0_intZ_updated <- stats::plogis(
    stats::coef(u_tilt)[1] +
      stats::qlogis(bound_precision(u_pred_Ais0_intZ_rescaled)) +
    stats::coef(u_tilt)[2] * j_aux_A0
  )
  u_pred_Ais0_intZ_updated <- scale_from_unit(u_pred_Ais0_intZ_updated)
  cv_eif_results[, u_pred_Ais0_intZ := u_pred_Ais0_intZ_updated]

  u_pred_Anat_intZ_updated <- data$A * cv_eif_results$u_pred_Ais1_intZ +
    (1 - data$A) * cv_eif_results$u_pred_Ais0_intZ
  cv_eif_results[, u_pred_Anat_intZ := u_pred_Anat_intZ_updated]

  # compute TML estimation components for the direct and indirect effects
  est_direct <- with(cv_eif_results,
    u_pred_Ais1_intZ * g_pred_natural_A1 +
    u_pred_Ais0_intZ * (1 - g_pred_natural_A1) -
    (u_pred_Ais1 * g_pred_shifted_A1 +
     u_pred_Ais0 * (1 - g_pred_shifted_A1))
  )
  est_indirect <- with(cv_eif_results,
    (u_pred_Ais1 - u_pred_Ais1_intZ) * g_pred_shifted_A1 +
    (u_pred_Ais0 - u_pred_Ais0_intZ) * (1 - g_pred_shifted_A0)
  )

  # compute updated EIFs post-targeting for direct and indirect effects
  eif_direct <- est_direct +
    h_aux_direct * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
    k_aux_direct * (data$L - cv_eif_results$b_pred_L1_Anat) +
    m_aux_direct * (data$A - cv_eif_results$g_pred_natural_A1) +
    (cv_eif_results$u_pred_Anat - cv_eif_results$u_pred_Anat_intZ)
  eif_indirect <- est_indirect +
    h_aux_indirect * (data$Y - cv_eif_results$m_pred_Lnat_Anat) +
    k_aux_indirect * (data$L - cv_eif_results$b_pred_L1_Anat) +
    m_aux_indirect * (data$A - cv_eif_results$g_pred_natural_A1) +
    j_aux * (cv_eif_results$u_pred_Anat - cv_eif_results$u_pred_Anat_intZ)

  # compute TML estimate and estimated inference
  tml_est_direct <- mean(est_direct)
  tml_est_indirect <- mean(est_indirect)
  stderr_direct <- sqrt(stats::var(eif_direct) / data[, .N])
  stderr_indirect <- sqrt(stats::var(eif_indirect) / data[, .N])

  # create output and return
  tml_est_out <- tibble::as_tibble(list(
    param = c("direct", "indirect"),
    est = c(tml_est_direct, tml_est_indirect),
    stderr = c(stderr_direct, stderr_indirect)
  ))
  attr(tml_est_out, "param") <- "stochastic_interventional"
  return(tml_est_out)
}
