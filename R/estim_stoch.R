#' Inverse probability weighted estimator
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param delta A \code{numeric} value indicating the degree of shift in the
#'  intervention to be used in defining the causal quantity of interest. In the
#'  case of binary interventions, this takes the form of an incremental
#'  propensity score shift, acting as a multiplier of the odds with which a
#'  given observational unit receives the intervention (EH Kennedy, 2018, JASA;
#'  <doi:10.1080/01621459.2017.1422737>).
#' @param g_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model.
#' @param e_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a reparametrized model
#'  for the mediator(s) that is equivalent to a propensity score conditioning
#'  on the mediators.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by \code{\link{medshift}}.
#' @param ... Other arguments currently ignored.
stoch_est_ipw <- function(data,
                          delta,
                          g_learners,
                          e_learners,
                          w_names,
                          z_names,
                          ...) {
  # fit regression for incremental propensity score intervention
  g_out <- fit_g_mech(
    data = data, delta = delta,
    learners = g_learners, w_names = w_names
  )
  g_shifted <- data$A * g_out$g_est$g_pred_shifted_A1 +
    (1 - data$A) * g_out$g_est$g_pred_shifted_A0

  # fit clever regression for treatment, conditional on mediators
  e_out <- fit_e_mech(
    data = data, learners = e_learners,
    z_names = z_names, w_names = w_names
  )
  e_pred <- data$A * e_out$e_est$e_pred_natural_A1 +
    (1 - data$A) * e_out$e_est$e_pred_natural_A0

  # stabilize weights (dividing by sample average) and compute IPW estimate
  mean_weights <- mean(g_shifted / e_pred)
  ipw_estimate <- mean(((g_shifted / e_pred) / mean_weights) * data$Y)

  # output
  ipw_est_out <- list(theta = ipw_estimate, type = "IPW")
  return(ipw_est_out)
}

###############################################################################

#' Parametric substitution estimator
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param delta A \code{numeric} value indicating the degree of shift in the
#'  intervention to be used in defining the causal quantity of interest. In the
#'  case of binary interventions, this takes the form of an incremental
#'  propensity score shift, acting as a multiplier of the odds with which a
#'  given observational unit receives the intervention (EH Kennedy, 2018, JASA;
#'  <doi:10.1080/01621459.2017.1422737>).
#' @param g_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model.
#' @param m_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit an outcome regression.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param ... Other arguments currently ignored.
stoch_est_sub <- function(data,
                          delta,
                          g_learners,
                          m_learners,
                          w_names,
                          z_names,
                          ...) {
  # estimate propensity score
  g_out <- fit_g_mech(
    data = data, delta = delta,
    learners = g_learners, w_names = w_names
  )

  # fit regression for incremental propensity score intervention
  m_out <- fit_m_mech(
    data = data, learners = m_learners,
    z_names = z_names, w_names = w_names
  )

  # compute Dzw component of EIF using convenience function
  Dzw_groupwise <- compute_Dzw(g_out = g_out, m_out = m_out)

  # compute estimator
  estim_sub <- mean(Dzw_groupwise$dzw_cntrl) + mean(Dzw_groupwise$dzw_treat)

  # output
  estim_sub_out <- list(theta = estim_sub, type = "substitution")
  return(estim_sub_out)
}

###############################################################################

#' Efficient One-Step Estimator
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param delta A \code{numeric} value indicating the magnitude of shift in the
#'  treatment that defines the counterfactual quantity of interest. In the case
#'  of binary treatments, this defines the incremental propensity score shift,
#'  which acts as a multiplier of the odds with which an observational unit
#'  receives treatment (EH Kennedy, 2018; <doi:10.1080/01621459.2017.1422737>).
#'  When the treatment is quantitative, the defines the degree of shift for a
#'  modified treatment policy but non-binary treatments are not  yet supported.
#' @param g_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model.
#' @param e_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a reparametrized model
#'  for the mediator(s) that is equivalent to a propensity score conditioning
#'  on the mediators.
#' @param m_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit an outcome regression.
#' @param phi_learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a nuisance regression of
#'  a "derived" pseudo-outcome (contrast of outcome regressions under different
#'  treatment conditions), conditional on baseline covariates. This is of the
#'  following form phi(W) = E[m(A = 1, Z, W) - m(A = 0, Z, W) | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by \code{\link{medshift}}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by \code{\link{medshift}}.
#' @param cv_folds A \code{numeric} specifying the number of folds to be
#'  created for cross-validation. Use of cross-validation / cross-fitting
#'  allows for entropy conditions on the efficient estimator to be relaxed. For
#'  compatibility with \code{\link[origami]{make_folds}}, this value must be
#'  greater than or equal to 2; the default is to create 10 folds.
#'
#' @importFrom stats var
#' @importFrom origami make_folds cross_validate folds_vfold
stoch_est_onestep <- function(data,
                              delta,
                              g_learners,
                              e_learners,
                              m_learners,
                              phi_learners,
                              w_names,
                              z_names,
                              cv_folds = 10L) {
  # use origami to perform CV-SL, fitting/evaluating EIF components per fold
  eif_component_names <- c("Dy", "Da", "Dzw")

  # create folds for use with origami::cross_validate
  folds <- origami::make_folds(data,
    fold_fun = origami::folds_vfold,
    V = cv_folds,
    cluster_ids = data[["ids"]]
  )

  # perform the cv_eif procedure on a per-fold basis
  cv_eif_results <- origami::cross_validate(
    cv_fun = stoch_cv_eif,
    folds = folds,
    data = data,
    delta = delta,
    g_learners = g_learners,
    e_learners = e_learners,
    m_learners = m_learners,
    phi_learners = phi_learners,
    w_names = w_names,
    z_names = z_names,
    use_future = FALSE,
    .combine = FALSE
  )

  # combine results of EIF components for full EIF
  est_over_delta <- lapply(seq_along(delta), function(iter) {
    # compute influence function, parameter, variance for given delta
    D_obs <- lapply(cv_eif_results[[iter]], function(x) {
      D_obs_fold <- rowSums(x[, ..eif_component_names])
      return(D_obs_fold)
    })

    # get estimated observation-level values of EIF
    estim_eif <- do.call(c, D_obs)

    # compute one-step estimate of parameter and variance from EIF
    estim_onestep_param <- mean(estim_eif)
    # combine repeated EIF estimates if IDs are non-unique
    if (length(unique(data[["ids"]])) < nrow(data)) {
      estim_eif_combined <- by(estim_eif, as.numeric(data[["ids"]]), mean,
        simplify = FALSE
      )
      estim_eif_reduced <- unname(do.call(c, estim_eif_combined))
      estim_onestep_var <- stats::var(estim_eif_reduced) /
        length(estim_eif_reduced)
    } else {
      estim_onestep_var <- stats::var(estim_eif) / length(estim_eif)
    }

    # output for a given delta
    estim_onestep_out <- list(
      theta = estim_onestep_param,
      var = estim_onestep_var,
      eif = (estim_eif - estim_onestep_param),
      type = "onestep"
    )
    return(estim_onestep_out)
  })

  # output
  if (length(delta) == 1) {
    return(unlist(est_over_delta, recursive = FALSE))
  } else {
    return(est_over_delta)
  }
}
