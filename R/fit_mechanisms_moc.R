################################################################################

#' Fit mediator-outcome confounder score without conditioning on mediators
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, L, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @contrast ...
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., g = P(A | W).
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_q_mech <- function(data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       w_names) {
  # set argument defaults
  shift_type <- match.arg(shift_type)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }
  data_intervene[, A := A + contrast]

  # construct task for fitting score for mediator-outcome confounder
  q_intervened_task <- sl3::sl3_Task$new(
    data = data_intervene,
    covariates = c("A", w_names),
    outcome_type = "binomial",
    outcome = "L"
  )

  # fitting score for mediator-outcome confounder
  q_fit <- lrnr_stack$train(q_intervened_task)

  # get predictions from natural propensity score model for intervened data
  q_intervened_pred <- q_fit$predict(g_intervened_task)

  # bounding to numerical precision and for positivity considerations
  out_q_mat <- cbind(q_intervened_pred)
  out_q_est <- apply(out_q_mat, 2, function(x) {
                       x_precise <- bound_precision(x)
                       x_bounded <- bound_propensity(x_precise)
                       return(x_bounded)
                    })
  out_q_est <- data.table::as.data.table(out_q_est)
  data.table::setnames(out_q_est, c("q_pred")),

  # output
  out <- list(
    q_est = out_q_est,
    q_fit = q_fit
  )
  return(out)
}

################################################################################

#' Fit mediator-outcome confounder score while conditioning on mediators
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, L, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated as part of a call to the user-facing
#'  wrapper function \code{medshift}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @contrast ...
#' @param lrnr_stack A \code{Stack} object, or other learner class (inheriting
#'  from \code{Lrnr_base}), containing a single or set of instantiated learners
#'  from the \code{sl3} package, to be used in fitting a model for the
#'  propensity score, i.e., g = P(A | W).
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by a call to the wrapper function \code{medshift}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table as.data.table copy setnames ":="
#' @importFrom sl3 sl3_Task
#
fit_r_mech <- function(data,
                       valid_data = NULL,
                       contrast,
                       lrnr_stack,
                       z_names,
                       w_names) {
  # set argument defaults
  shift_type <- match.arg(shift_type)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_intervene <- data.table::copy(data)
  } else {
    # copy only validation data
    data_intervene <- data.table::copy(valid_data)
  }
  data_intervene[, A := A + contrast]

  # construct task for fitting score for mediator-outcome confounder
  r_intervened_task <- sl3::sl3_Task$new(
    data = data_intervene,
    covariates = c("A", z_names, w_names),
    outcome_type = "binomial",
    outcome = "L"
  )

  # fitting score for mediator-outcome confounder
  r_fit <- lrnr_stack$train(r_intervened_task)

  # get predictions from natural propensity score model for intervened data
  r_intervened_pred <- r_fit$predict(r_intervened_task)

  # bounding to numerical precision and for positivity considerations
  out_r_mat <- cbind(r_intervened_pred)
  out_r_est <- apply(out_r_mat, 2, function(x) {
                       x_precise <- bound_precision(x)
                       x_bounded <- bound_propensity(x_precise)
                       return(x_bounded)
                    })
  out_r_est <- data.table::as.data.table(out_r_est)
  data.table::setnames(out_r_est, c("r_pred")),

  # output
  out <- list(
    r_est = out_r_est,
    r_fit = r_fit
  )
  return(out)
}
