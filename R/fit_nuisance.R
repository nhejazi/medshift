#' Fit propensity score with incremental intervention
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param delta A \code{numeric} value indicating the magnitude of shift in the
#'  treatment that defines the counterfactual quantity of interest. In the case
#'  of binary treatments, this defines the incremental propensity score shift,
#'  which acts as a multiplier of the odds with which an observational unit
#'  receives treatment (EH Kennedy, 2018; <doi:10.1080/01621459.2017.1422737>).
#'  When the treatment is quantitative, the defines the degree of shift for a
#'  modified treatment policy but non-binary treatments are not  yet supported.
#' @param learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by \code{\link{medshift}}.
#'
#' @importFrom data.table as.data.table copy ":="
#' @importFrom sl3 sl3_Task
fit_g_mech <- function(data, valid_data = NULL, delta, learners, w_names) {
  #  construct task for propensity score fit
  g_task <- sl3::sl3_Task$new(
    data = data,
    covariates = w_names,
    outcome = "A",
    outcome_type = "binomial",
    id = "ids"
  )

  # fit and predict
  g_fit_stack <- learners$train(g_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_pred <- data.table::copy(data)
  } else {
    # copy only validation data
    data_pred <- data.table::copy(valid_data)
  }

  # create task for estimating propensity score P(A = 1 | W)
  g_task_pred <- sl3::sl3_Task$new(
    data = data_pred,
    covariates = w_names,
    outcome = "A",
    id = "ids"
  )

  # get predictions for "natural" (observed) propensity score
  g_pred_natural_A1 <- g_fit_stack$predict(g_task_pred) %>%
    bound_precision() %>%
    bound_propensity()
  g_pred_natural_A0 <- 1 - g_pred_natural_A1 %>%
    bound_precision() %>%
    bound_propensity()

  # directly computed the shifted propensity score (by symmetry for A = 0)
  g_pred_shifted_A1 <- ipsi_delta(g_pred_natural_A1, delta) %>%
    bound_precision() %>%
    bound_propensity()
  g_pred_shifted_A0 <- (1 - g_pred_shifted_A1) %>%
    bound_precision() %>%
    bound_propensity()

  # output
  out <- list(
    g_est = data.table::data.table(cbind(
      g_pred_natural_A1 = g_pred_natural_A1,
      g_pred_natural_A0 = g_pred_natural_A0,
      g_pred_shifted_A1 = g_pred_shifted_A1,
      g_pred_shifted_A0 = g_pred_shifted_A0
    )),
    g_fit = g_fit_stack
  )
  return(out)
}

###############################################################################

#' Fit reparametrized propensity score conditioning on mediators
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, L, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a reparametrized model
#'  for the mediator(s) that is equivalent to a propensity score conditioning
#'  on the mediators.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by \code{\link{medshift}}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table as.data.table copy
#' @importFrom sl3 sl3_Task
fit_e_mech <- function(data, valid_data = NULL, learners, z_names, w_names) {
  # construct task for nuisance parameter fit
  e_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c(z_names, w_names),
    outcome = "A",
    outcome_type = "binomial",
    id = "ids"
  )

  # fit and predict
  e_fit_stack <- learners$train(e_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_pred <- data.table::copy(data)
  } else {
    # copy only validation data
    data_pred <- data.table::copy(valid_data)
  }

  # create task for estimating propensity score P(A = 1 | Z, W)
  e_task_pred <- sl3::sl3_Task$new(
    data = data_pred,
    covariates = c(z_names, w_names),
    outcome = "A",
    id = "ids"
  )

  # predict from trained model on counterfactual data (by symmetry for A = 0)
  e_pred_natural_A1 <- e_fit_stack$predict(e_task_pred) %>%
    bound_precision() %>%
    bound_propensity()
  e_pred_natural_A0 <- (1 - e_pred_natural_A1) %>%
    bound_precision() %>%
    bound_propensity()

  # output
  out <- list(
    e_est = data.table::data.table(cbind(
      e_pred_natural_A1 = e_pred_natural_A1,
      e_pred_natural_A0 = e_pred_natural_A0
    )),
    e_fit = e_fit_stack
  )
  return(out)
}

###############################################################################

#' Fit intermediate confounder deconfounding score
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, L, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model
#'  for the intermediate confounder, adjusting for the baseline covariates and
#'  the treatment both.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table as.data.table copy
#' @importFrom sl3 sl3_Task
fit_b_mech <- function(data, valid_data = NULL, learners, w_names) {
  # construct task for nuisance parameter fit
  b_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c("A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )

  # fit and predict
  b_fit_stack <- learners$train(b_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_pred <- data.table::copy(data)
  } else {
    # copy only validation data
    data_pred <- data.table::copy(valid_data)
  }

  # create task for estimating intermediate confounding score P(L = 1 | A, W)
  b_Anat_task <- sl3::sl3_Task$new(
    data = data_pred,
    covariates = c("A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )

  # predict from trained model on observed data (by symmetry for L = 0)
  b_pred_L1_Anat <- b_fit_stack$predict(b_Anat_task) %>%
    bound_precision() %>%
    bound_propensity()
  b_pred_L0_Anat <- (1 - b_pred_L1_Anat) %>%
    bound_precision() %>%
    bound_propensity()
  
  # create tasks with counterfactual data for {do(A = 1), do(A = 0)}
  b_Ais0_task <- sl3::sl3_Task$new(
    data = data_pred[, A := 0],
    covariates = c("A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )
  b_Ais1_task <- sl3::sl3_Task$new(
    data = data_pred[, A := 1],
    covariates = c("A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )

  # predict from trained model on counterfactual data
  b_pred_L1_Ais0 <- b_fit_stack$predict(b_Ais0_task) %>%
    bound_precision() %>%
    bound_propensity()
  b_pred_L1_Ais1 <- b_fit_stack$predict(b_Ais1_task) %>%
    bound_precision() %>%
    bound_propensity()

  # output
  out <- list(
    b_est = data.table::data.table(cbind(
      b_pred_L1_Anat = b_pred_L1_Anat,
      b_pred_L0_Anat = b_pred_L0_Anat,
      b_pred_L1_Ais0 = b_pred_L1_Ais0,
      b_pred_L1_Ais1 = b_pred_L1_Ais1
    )),
    b_fit = b_fit_stack
  )
  return(out)
}

###############################################################################

#' Fit intermediate confounder deconfounding score conditional on mediators
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, L, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a propensity score model
#'  for the intermediate confounder, adjusting for the baseline covariates, the
#'  treatment, and the mediators.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by \code{\link{medshift}}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by a call to the wrapper function \code{medshift}.
#'
#' @importFrom data.table as.data.table copy
#' @importFrom sl3 sl3_Task
fit_d_mech <- function(data, valid_data = NULL, learners, z_names, w_names) {
  # construct task for nuisance parameter fit
  d_task <- sl3::sl3_Task$new(
    data = data,
    covariates = c(z_names, "A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )

  # fit and predict
  d_fit_stack <- learners$train(d_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full data
    data_pred <- data.table::copy(data)
  } else {
    # copy only validation data
    data_pred <- data.table::copy(valid_data)
  }

  # create task for estimating intermediate confounding score P(L = 1 | A, W)
  d_Anat_task <- sl3::sl3_Task$new(
    data = data_pred,
    covariates = c(z_names, "A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )

  # predict from trained model on observed data (for L = 0 by symmetry)
  d_pred_L1_Anat <- d_fit_stack$predict(d_Anat_task) %>%
    bound_precision() %>%
    bound_propensity()
  d_pred_L0_Anat <- (1 - d_pred_L1_Anat) %>%
    bound_precision() %>%
    bound_propensity()

  # create tasks with counterfactual data for {do(A = 1), do(A = 0)}
  d_Ais0_task <- sl3::sl3_Task$new(
    data = data.table::copy(data_pred)[, A := 0],
    covariates = c(z_names, "A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )
  d_Ais1_task <- sl3::sl3_Task$new(
    data = data.table::copy(data_pred)[, A := 1],
    covariates = c(z_names, "A", w_names),
    outcome = "L",
    outcome_type = "binomial",
    id = "ids"
  )

  # predict from trained model on counterfactual data
  d_pred_L1_Ais0 <- d_fit_stack$predict(d_Ais0_task) %>%
    bound_precision() %>%
    bound_propensity()
  d_pred_L1_Ais1 <- d_fit_stack$predict(d_Ais1_task) %>%
    bound_precision() %>%
    bound_propensity()

  # output
  out <- list(
    d_est = data.table::data.table(cbind(
      d_pred_L1_Anat = d_pred_L1_Anat,
      d_pred_L0_Anat = d_pred_L0_Anat,
      d_pred_L1_Ais0 = d_pred_L1_Ais0,
      d_pred_L1_Ais1 = d_pred_L1_Ais1
    )),
    d_fit = d_fit_stack
  )
  return(out)
}

###############################################################################

#' Fit outcome regression
#'
#' @param data A \code{data.table} containing the observed data, with columns
#'  in the order specified by the NPSEM (Y, Z, L, A, W), with column names set
#'  appropriately based on the original input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{data}, to be used for estimation
#'  via cross-fitting. Optional, defaulting to \code{NULL}.
#' @param learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit an outcome regression.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by \code{\link{medshift}}.
#' @param z_names A \code{character} vector of the names of the columns that
#'  correspond to mediators (Z). The input for this argument is automatically
#'  generated by \code{\link{medshift}}.
#'
#' @importFrom data.table as.data.table copy
#' @importFrom sl3 sl3_Task
fit_m_mech <- function(data, valid_data = NULL, learners, z_names, w_names) {
  # set conditioning set based on presence of intermediate confounder
  if ("L" %in% colnames(data)) {
    covars_names = c(z_names, "L", "A", w_names)
  } else {
    covars_names = c(z_names, "A", w_names)
  }

  #  construct task for outcome regression
  m_task <- sl3::sl3_Task$new(
    data = data,
    covariates = covars_names,
    outcome = "Y",
    id = "ids"
  )

  # fit and predict (training predictions if valid_data = NULL, else full-data)
  m_fit_stack <- learners$train(m_task)

  # use full data for counterfactual prediction if no validation data provided
  if (is.null(valid_data)) {
    # copy full-data
    data_Ais1 <- data.table::copy(data)[, A := 1]
    data_Ais0 <- data.table::copy(data)[, A := 0]
  } else {
    # copy validation data
    data_Ais1 <- data.table::copy(valid_data)[, A := 1]
    data_Ais0 <- data.table::copy(valid_data)[, A := 0]
  
    # NOTE: downstream fitting of nuisance regression requires estimates on the
    #       training set for the pseudo-outcome, i.e., m(Z,A=1,W) - m(Z,A=0,W)
    m_Ais1_task_training <- sl3::sl3_Task$new(
      data = data.table::copy(data)[, A := 1],
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais1_training <- m_fit_stack$predict(m_Ais1_task_training)

    # repeat for counterfactual do(A = 0)
    m_Ais0_task_training <- sl3::sl3_Task$new(
      data = data.table::copy(data)[, A := 0],
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais0_training <- m_fit_stack$predict(m_Ais0_task_training)
  }

  # NOTE: the following are either validation-set counterfactual predictions
  #       OR full-data counterfactual predictions (when valid_data = NULL)
  # create task for counterfactual data under do(A = 1)
  if ("L" %in% colnames(data)) {
    # create counterfactual data and predict under {do(A = 1), do(L = 0)}
    m_Ais1_Lis0_task <- sl3::sl3_Task$new(
      data = data.table::copy(data_Ais1)[, L := 0],
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais1_Lis0 <- m_fit_stack$predict(m_Ais1_Lis0_task)

    # create counterfactual data and predict under {do(A = 1), do(L = 1)}
    m_Ais1_Lis1_task <- sl3::sl3_Task$new(
      data = data.table::copy(data_Ais1)[, L := 1],
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais1_Lis1 <- m_fit_stack$predict(m_Ais1_Lis1_task)

    # create counterfactual data and predict under {do(A = 0), do(L = 0)}
    m_Ais0_Lis0_task <- sl3::sl3_Task$new(
      data = data.table::copy(data_Ais0)[, L := 0],
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais0_Lis0 <- m_fit_stack$predict(m_Ais0_Lis0_task)

    # create counterfactual data and predict under {do(A = 0), do(L = 1)}
    m_Ais0_Lis1_task <- sl3::sl3_Task$new(
      data = data.table::copy(data_Ais0)[, L := 1],
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais0_Lis1 <- m_fit_stack$predict(m_Ais0_Lis1_task)

    # created predictions marginalized over counterfactual L for ease of output
    m_pred_Ais1 <- data_Ais1$L * m_pred_Ais1_Lis1 + (1 - data_Ais1$L) *
      m_pred_Ais1_Lis0
    m_pred_Ais0 <- data_Ais0$L * m_pred_Ais0_Lis1 + (1 - data_Ais0$L) *
      m_pred_Ais0_Lis0
  } else {
    # create task for counterfactual data under do(A = 1)
    m_Ais1_task <- sl3::sl3_Task$new(
      data = data_Ais1,
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais1 <- m_fit_stack$predict(m_Ais1_task)

    # create task for counterfactual data under do(A = 0)
    m_Ais0_task <- sl3::sl3_Task$new(
      data = data_Ais0,
      covariates = covars_names,
      outcome = "Y",
      id = "ids"
    )
    m_pred_Ais0 <- m_fit_stack$predict(m_Ais0_task)
  }

  # output
  out <- list(
    m_est = data.table::data.table(cbind(
      m_pred_Ais1 =
        if ("L" %in% colnames(data)) {
          cbind(
            m_pred_Ais1_Lis0,
            m_pred_Ais1_Lis1
          )
        } else {
          m_pred_Ais1
        },
      m_pred_Ais0 =
        if ("L" %in% colnames(data)) {
          cbind(
            m_pred_Ais0_Lis0,
            m_pred_Ais0_Lis1
          )
        } else {
          m_pred_Ais0
        }
    )),
    # NOTE: these are only for the downstream construction of pseudo-outcome
    #       for "nested" nuisance functional
    m_est_pseudo = data.table::data.table(cbind(
      m_pred_Ais1 =
        if (!is.null(valid_data)) {
          m_pred_Ais1_training
        } else {
          m_pred_Ais1
        },
      m_pred_Ais0 =
        if (!is.null(valid_data)) {
          m_pred_Ais0_training
        } else {
          m_pred_Ais0
        }
    )),
    m_fit_sl = m_fit_stack
  )
  return(out)
}

###############################################################################

#' Fit pseudo-outcome nuisance parameter for difference of outcome regressions
#'
#' @param train_data A \code{data.table} containing the observed data, with
#'  columns in the order specified by the NPSEM (Y, Z, A, W), with column
#'  names set appropriately based on the input data. Such a structure is merely
#'  a convenience utility to passing data around to the various core estimation
#'  routines and is automatically generated by \code{\link{medshift}}.
#' @param valid_data A holdout data set, with columns exactly matching those
#'  appearing in the preceding argument \code{train_data}, to be used for
#'  estimation via cross-fitting. Not optional for this nuisance parameter.
#' @param learners A \code{\link[sl3]{Stack}} (or other learner class that
#'  inherits from \code{\link[sl3]{Lrnr_base}}), containing a single or set of
#'  instantiated learners from \pkg{sl3}, used to fit a nuisance regression of
#'  a "derived" pseudo-outcome (contrast of outcome regressions under different
#'  treatment conditions), conditional on baseline covariates. This is of the
#'  following form phi(W) = E[m(A = 1, Z, W) - m(A = 0, Z, W) | W).
#' @param m_out Results object outcome regression \code{\link{fit_m_mech}}.
#' @param w_names A \code{character} vector of the names of the columns that
#'  correspond to baseline covariates (W). The input for this argument is
#'  automatically generated by \code{\link{medshift}}.
#'
#' @importFrom data.table data.table as.data.table
#' @importFrom sl3 sl3_Task
fit_phi_mech <- function(train_data, valid_data, learners, m_out, w_names) {
  # regression on pseudo-outcome for this nuisance parameter
  # NOTE: first, learn the regression model using the training data
  m_pred_Ais1_training <- m_out$m_est_pseudo$m_pred_Ais1
  m_pred_Ais0_training <- m_out$m_est_pseudo$m_pred_Ais0
  m_pred_diff_training <- m_pred_Ais1_training - m_pred_Ais0_training

  # construct data structure for use with task objects
  phi_data_training <- data.table::data.table(
    m_diff = m_pred_diff_training,
    train_data[, ..w_names],
    ids = train_data[["ids"]]
  )
  phi_task_training <- sl3::sl3_Task$new(
    data = phi_data_training,
    covariates = w_names,
    outcome = "m_diff",
    outcome_type = "continuous",
    id = "ids"
  )

  # fit stack of learners to learn the regression model for phi
  phi_fit_training <- learners$train(phi_task_training)

  # NOW, predict on the validation data
  # NOTE: first, as before, must construct the pseudo-outcome
  m_pred_Ais1_validation <- m_out$m_est$m_pred_Ais1
  m_pred_Ais0_validation <- m_out$m_est$m_pred_Ais0
  m_pred_diff_validation <- m_pred_Ais1_validation - m_pred_Ais0_validation

  # construct data structure for use with task objects
  phi_data_validation <- data.table::data.table(
    m_diff = m_pred_diff_validation,
    valid_data[, ..w_names],
    ids = valid_data[["ids"]]
  )
  phi_task_validation <- sl3::sl3_Task$new(
    data = phi_data_validation,
    covariates = w_names,
    outcome = "m_diff",
    outcome_type = "continuous",
    id = "ids"
  )

  # predict and return for validation set only
  phi_est_validation <- phi_fit_training$predict(phi_task_validation)
  return(phi_est_validation)
}
